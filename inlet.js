// Generated by CoffeeScript 1.6.3
((function() {
  var HSLCircle, Picker, cssColorToRGB, fmod, hslToCSS, hslToRGB, hueToRGB, isValidCSSColor, map, normalizeColor, rgbToHSL, style, __slice = [].slice;
  hueToRGB = function(m1, m2, h) {
    h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
    if (h * 6 < 1) {
      return m1 + (m2 - m1) * h * 6;
    }
    if (h * 2 < 1) {
      return m2;
    }
    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (.66666 - h) * 6;
    }
    return m1;
  };
  hslToRGB = function(h, s, l) {
    var m1, m2;
    m2 = l <= .5 ? l * (s + 1) : l + s - l * s;
    m1 = l * 2 - m2;
    return {
      r: hueToRGB(m1, m2, h + .33333),
      g: hueToRGB(m1, m2, h),
      b: hueToRGB(m1, m2, h - .33333)
    };
  };
  rgbToHSL = function(r, g, b) {
    var diff, h, l, max, min, s, sum;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    diff = max - min;
    sum = max + min;
    h = min === max ? 0 : r === max ? (60 * (g - b) / diff + 360) % 360 : g === max ? 60 * (b - r) / diff + 120 : 60 * (r - g) / diff + 240;
    l = sum / 2;
    s = l === 0 ? 0 : l === 1 ? 1 : l <= .5 ? diff / sum : diff / (2 - sum);
    return {
      h: h,
      s: s,
      l: l
    };
  };
  hslToCSS = function(h, s, l, a) {
    if (a != null) {
      return "hsla(" + fmod(Math.round(h * 180 / Math.PI), 360) + "," + Math.round(s * 100) + "%," + Math.round(l * 100) + "%," + a + ")";
    } else {
      return "hsl(" + fmod(Math.round(h * 180 / Math.PI), 360) + "," + Math.round(s * 100) + "%," + Math.round(l * 100) + "%)";
    }
  };
  cssColorToRGB = function(cssColor) {
    var b, g, m, r, rgb, s;
    s = document.createElement("span");
    document.body.appendChild(s);
    s.style.backgroundColor = cssColor;
    rgb = getComputedStyle(s).backgroundColor;
    document.body.removeChild(s);
    m = /^rgb\((\d+), (\d+), (\d+)\)$/.exec(rgb);
    if (!m) {
      m = /^rgba\((\d+), (\d+), (\d+), ([\d.]+)\)$/.exec(rgb);
    }
    r = parseInt(m[1]);
    g = parseInt(m[2]);
    b = parseInt(m[3]);
    if (m[4]) {
      return {
        r: r / 255,
        g: g / 255,
        b: b / 255,
        a: parseFloat(m[4])
      };
    }
    return {
      r: r / 255,
      g: g / 255,
      b: b / 255
    };
  };
  isValidCSSColor = function(cssColor) {
    var ret, s;
    s = document.createElement("span");
    document.body.appendChild(s);
    s.style.backgroundColor = cssColor;
    ret = s.style.backgroundColor.length > 0;
    s.remove();
    return ret;
  };
  style = function(tag, styles) {
    var n, v;
    for (n in styles) {
      v = styles[n];
      tag.style[n] = v;
    }
    return tag;
  };
  fmod = function(x, m) {
    x = x % m;
    if (x < 0) {
      x += m;
    }
    return x;
  };
  map = function(v, min, max) {
    return min + (max - min) * Math.min(1, Math.max(0, v));
  };
  HSLCircle = function() {
    function HSLCircle(radius, width, lightness) {
      var b, canvas, ctx, d, data, dx, dy, g, h, imgdata, r, s, x, y, _i, _j, _ref, _ref1, _ref2;
      this.radius = radius;
      this.width = width;
      this.lightness = lightness;
      radius = this.radius;
      width = this.width;
      canvas = this.canvas = document.createElement("canvas");
      canvas.width = canvas.height = radius * 2;
      ctx = canvas.getContext("2d");
      imgdata = ctx.createImageData(canvas.width, canvas.height);
      data = imgdata.data;
      for (y = _i = 0, _ref = canvas.height; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = canvas.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          dy = y - radius;
          dx = x - radius;
          d = Math.sqrt(dy * dy + dx * dx);
          if (d > radius + 1.5) {
            continue;
          }
          d -= 10;
          s = Math.max(0, Math.min(1, d / (radius - width / 2 - 10)));
          h = Math.atan2(dy, dx) / (Math.PI * 2);
          _ref2 = hslToRGB(h, s, this.lightness), r = _ref2.r, g = _ref2.g, b = _ref2.b;
          data[(y * canvas.width + x) * 4 + 0] = r * 255;
          data[(y * canvas.width + x) * 4 + 1] = g * 255;
          data[(y * canvas.width + x) * 4 + 2] = b * 255;
          data[(y * canvas.width + x) * 4 + 3] = 255;
        }
      }
      ctx.putImageData(imgdata, 0, 0);
    }
    HSLCircle.prototype.drawHSLCircle = function(canvas, saturation) {
      var ctx, highlighted_r, radius, width;
      canvas.width = canvas.height = 2 * this.radius;
      ctx = canvas.getContext("2d");
      width = this.width;
      radius = this.radius;
      highlighted_r = map(saturation, width, radius);
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.3)";
      ctx.beginPath();
      ctx.arc(radius, radius, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.arc(radius, radius, highlighted_r, 0, Math.PI * 2);
      ctx.arc(radius, radius, highlighted_r - width, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.globalCompositeOperation = "source-in";
      ctx.drawImage(this.canvas, 0, 0);
      return ctx.restore();
    };
    return HSLCircle;
  }();
  normalizeColor = function(color) {
    if (typeof color === "string") {
      color = cssColorToRGB(color);
    }
    if (color.r != null && color.g != null && color.b != null) {
      color = rgbToHSL(color.r, color.g, color.b);
      color.h = color.h * Math.PI / 180;
    } else if (color.h != null && color.s != null && color.l != null) {
      color.h = color.h * Math.PI / 180;
    }
    return color;
  };
  Picker = function() {
    var attachEvents, makeCircle, makeColorPreview, makeKnob, makeLightnessSlider, makeRoot, radius, width;
    radius = 80;
    width = 25;
    function Picker(color) {
      this.color = normalizeColor(color);
      this.refColor = this.color;
      this.el = makeRoot();
      this.circleContainer = this.el.appendChild(makeCircle.call(this));
      this.lSlider = this.el.appendChild(makeLightnessSlider.call(this));
      this.colorPreview = this.el.appendChild(makeColorPreview.call(this));
      attachEvents.call(this);
      this.setLightness(this.color.l);
    }
    Picker.prototype.setHue = function(h) {
      var b, oR, r;
      this.color.h = h;
      r = map(this.color.s, width, radius) - width / 2;
      oR = radius - width / 2;
      style(this.hueKnob, {
        left: Math.round(oR + Math.cos(h) * r + 6 - 1) + "px",
        top: Math.round(oR + Math.sin(h) * r + 6 - 1) + "px"
      });
      this.colorPreview.style.backgroundColor = this.lKnob.style.backgroundColor = this.hueKnob.style.backgroundColor = hslToCSS(this.color.h, this.color.s, this.color.l);
      b = hslToCSS(this.color.h, this.color.s, .5);
      this.lSlider.style.backgroundImage = "-webkit-linear-gradient(bottom, black, " + b + " 50%, white)";
      this.lSlider.style.backgroundImage = "-moz-linear-gradient(bottom, black, " + b + " 50%, white)";
      return this.emit("changed");
    };
    Picker.prototype.setSaturation = function(s) {
      this.color.s = s;
      this.circle.drawHSLCircle(this.circleCanvas, s);
      return this.setHue(this.color.h);
    };
    Picker.prototype.setLightness = function(l) {
      this.color.l = l;
      this.circle = new HSLCircle(radius, width, l);
      this.lKnob.style.top = (1 - l) * this.lSlider._height - 11 + "px";
      return this.setSaturation(this.color.s);
    };
    Picker.prototype.setHSL = function(h, s, l) {
      this.color.h = fmod(h, 360) * Math.PI / 180;
      this.color.s = Math.max(0, Math.min(1, s));
      l = Math.max(0, Math.min(1, l));
      return this.setLightness(l);
    };
    Picker.prototype.getHSL = function() {
      return {
        h: fmod(this.color.h * 180 / Math.PI, 360),
        s: this.color.s,
        l: this.color.l
      };
    };
    Picker.prototype.setRGB = function(r, g, b) {
      var h, l, s, _ref;
      _ref = rgbToHSL(r, g, b), h = _ref.h, s = _ref.s, l = _ref.l;
      return this.setHSL(h, s, l);
    };
    Picker.prototype.getRGB = function() {
      return hslToRGB(this.color.h / (Math.PI * 2), this.color.s, this.color.l);
    };
    Picker.prototype.getCSS = function() {
      return hslToCSS(this.color.h, this.color.s, this.color.l);
    };
    Picker.prototype.setCSS = function(css) {
      var b, g, r, _ref;
      _ref = cssColorToRGB(css), r = _ref.r, g = _ref.g, b = _ref.b;
      return this.setRGB(r, g, b);
    };
    Picker.prototype.on = function(e, l) {
      var _base;
      if (this._listeners == null) {
        this._listeners = {};
      }
      return ((_base = this._listeners)[e] != null ? (_base = this._listeners)[e] : _base[e] = []).push(l);
    };
    Picker.prototype.emit = function() {
      var args, e, l, _i, _len, _ref, _ref1, _results;
      e = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this._listeners) {
        _ref1 = (_ref = this._listeners[e]) != null ? _ref : [];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          l = _ref1[_i];
          _results.push(l.call.apply(l, [ this ].concat(__slice.call(args))));
        }
        return _results;
      }
    };
    Picker.prototype.removeListener = function(e, l) {
      var k;
      if (this._listeners[e]) {
        return this._listeners[e] = function() {
          var _i, _len, _ref, _results;
          _ref = this._listeners[e];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            k = _ref[_i];
            if (k !== l) {
              _results.push(k);
            }
          }
          return _results;
        }.call(this);
      }
    };
    attachEvents = function() {
      var c, updateCursor, _this = this;
      this.lKnob.onmousedown = function(e) {
        var move, up;
        document.documentElement.style.cursor = "pointer";
        window.addEventListener("mousemove", move = function(e) {
          var r, y;
          r = _this.lSlider.getBoundingClientRect();
          y = e.clientY - r.top;
          return _this.setLightness(Math.max(0, Math.min(1, 1 - y / _this.lSlider._height)));
        });
        window.addEventListener("mouseup", up = function(e) {
          window.removeEventListener("mousemove", move);
          window.removeEventListener("mouseup", up);
          window.removeEventListener("blur", up);
          return document.documentElement.style.cursor = "";
        });
        window.addEventListener("blur", up);
        e.preventDefault();
        return e.stopPropagation();
      };
      c = this.circleContainer;
      updateCursor = function(e) {
        var d, dx, dy, r, t, x, y;
        x = e.layerX;
        y = e.layerY;
        dx = x - radius;
        dy = y - radius;
        d = Math.sqrt(dx * dx + dy * dy);
        t = Math.atan2(dy, dx);
        r = map(_this.color.s, width, radius);
        if (r - width < d && d < r) {
          if (-Math.PI / 8 < t && t < Math.PI / 8 || t >= 7 * Math.PI / 8 || t <= -7 * Math.PI / 8) {
            return c.style.cursor = "ew-resize";
          } else if (Math.PI / 8 <= t && t < 3 * Math.PI / 8 || -7 * Math.PI / 8 < t && t <= -5 * Math.PI / 8) {
            return c.style.cursor = "nwse-resize";
          } else if (3 * Math.PI / 8 <= t && t < 5 * Math.PI / 8 || -5 * Math.PI / 8 < t && t <= -3 * Math.PI / 8) {
            return c.style.cursor = "ns-resize";
          } else if (5 * Math.PI / 8 <= t && t < 7 * Math.PI / 8 || -3 * Math.PI / 8 < t && t <= -Math.PI / 8) {
            return c.style.cursor = "nesw-resize";
          }
        } else {
          return c.style.cursor = "";
        }
      };
      c.addEventListener("mouseover", function(e) {
        var move, out;
        updateCursor(e);
        c.addEventListener("mousemove", move = function(e) {
          return updateCursor(e);
        });
        c.addEventListener("mouseout", out = function(e) {
          c.style.cursor = "";
          c.removeEventListener("mousemove", move);
          c.removeEventListener("mouseout", out);
          return window.removeEventListener("blur", out);
        });
        return window.addEventListener("blur", out);
      });
      c.addEventListener("mousedown", function(e) {
        var d, dx, dy, move, r, t, up, x, y;
        e.preventDefault();
        x = e.layerX;
        y = e.layerY;
        dx = x - radius;
        dy = y - radius;
        d = Math.sqrt(dx * dx + dy * dy);
        t = Math.atan2(dy, dx);
        r = map(_this.color.s, width, radius);
        if (!(r - width < d && d < r)) {
          return;
        }
        document.documentElement.style.cursor = c.style.cursor;
        window.addEventListener("mousemove", move = function(e) {
          var cx, cy, s;
          r = _this.circleCanvas.getBoundingClientRect();
          cx = r.left + r.width / 2;
          cy = r.top + r.height / 2;
          dx = e.clientX - cx;
          dy = e.clientY - cy;
          d = Math.sqrt(dx * dx + dy * dy);
          d -= 10;
          s = Math.max(0, Math.min(1, d / (radius - width / 2 - 10)));
          return _this.setSaturation(s);
        });
        window.addEventListener("mouseup", up = function(e) {
          window.removeEventListener("mousemove", move);
          window.removeEventListener("mouseup", up);
          window.removeEventListener("blur", up);
          return document.documentElement.style.cursor = "";
        });
        return window.addEventListener("blur", up);
      });
      return this.hueKnob.onmousedown = function(e) {
        var move, up;
        document.documentElement.style.cursor = "pointer";
        window.addEventListener("mousemove", move = function(e) {
          var cx, cy, r;
          r = _this.circleCanvas.getBoundingClientRect();
          cx = r.left + r.width / 2;
          cy = r.top + r.height / 2;
          return _this.setHue(Math.atan2(e.clientY - cy, e.clientX - cx));
        });
        window.addEventListener("mouseup", up = function(e) {
          window.removeEventListener("mousemove", move);
          window.removeEventListener("mouseup", up);
          window.removeEventListener("blur", up);
          return document.documentElement.style.cursor = "";
        });
        window.addEventListener("blur", up);
        e.preventDefault();
        return e.stopPropagation();
      };
    };
    makeRoot = function() {
      var div;
      div = document.createElement("div");
      div.className = "picker";
      style(div, {
        display: "inline-block",
        background: "hsl(0, 0%, 97%)",
        padding: "6px",
        borderRadius: "6px",
        boxShadow: "1px 1px 5px hsla(0, 0%, 39%, 0.2), hsla(0, 0%, 100%, 0.9) 0px 0px 1em 0.3em inset",
        border: "1px solid hsla(0, 0%, 59%, 0.2)",
        position: "absolute",
        backgroundImage: "-webkit-linear-gradient(left top, hsla(0, 0%, 0%, 0.05) 25%, transparent 25%, transparent 50%, hsla(0, 0%, 0%, 0.05) 50%, hsla(0, 0%, 0%, 0.05) 75%, transparent 75%, transparent)",
        backgroundSize: "40px 40px"
      });
      style(div, {
        backgroundImage: "-moz-linear-gradient(left top, hsla(0, 0%, 0%, 0.05) 25%, transparent 25%, transparent 50%, hsla(0, 0%, 0%, 0.05) 50%, hsla(0, 0%, 0%, 0.05) 75%, transparent 75%, transparent)",
        zIndex: "1000"
      });
      return div;
    };
    makeCircle = function() {
      var circleContainer, k;
      circleContainer = document.createElement("div");
      style(circleContainer, {
        display: "inline-block",
        width: radius * 2 + "px",
        height: radius * 2 + "px",
        borderRadius: radius + "px",
        boxShadow: "0px 0px 7px rgba(0,0,0,0.3)"
      });
      circleContainer.appendChild(this.circleCanvas = document.createElement("canvas"));
      this.hueKnob = k = makeKnob(27);
      circleContainer.appendChild(k);
      return circleContainer;
    };
    makeLightnessSlider = function() {
      var k, lSlider;
      lSlider = document.createElement("div");
      style(lSlider, {
        display: "inline-block",
        width: "20px",
        height: radius * 2 - 22 + "px",
        marginLeft: "6px",
        borderRadius: "10px",
        boxShadow: "hsla(0, 100%, 100%, 0.1) 0 1px 2px 1px inset, hsla(0, 100%, 100%, 0.2) 0 1px inset, hsla(0, 0%, 0%, 0.4) 0 -1px 1px inset, hsla(0, 0%, 0%, 0.4) 0 1px 1px",
        position: "relative",
        top: "-11px"
      });
      lSlider._height = radius * 2 - 22;
      this.lKnob = k = makeKnob(22);
      style(k, {
        left: "-1px"
      });
      lSlider.appendChild(k);
      return lSlider;
    };
    makeColorPreview = function() {
      var colorPreview, originalColor, originalColorTransparent;
      colorPreview = document.createElement("div");
      originalColor = hslToCSS(this.refColor.h, this.refColor.s, this.refColor.l);
      originalColorTransparent = hslToCSS(this.refColor.h, this.refColor.s, this.refColor.l, 0);
      style(colorPreview, {
        boxShadow: "hsla(0, 0%, 0%, 0.5) 0 1px 5px, hsla(0, 100%, 100%, 0.4) 0 1px 1px inset, hsla(0, 0%, 0%, 0.3) 0 -1px 1px inset",
        height: "25px",
        marginTop: "6px",
        borderRadius: "3px",
        backgroundImage: "-webkit-linear-gradient(-20deg, " + originalColorTransparent + ", " + originalColorTransparent + " 69%, " + originalColor + " 70%, " + originalColor + ")"
      });
      style(colorPreview, {
        backgroundImage: "-moz-linear-gradient(-20deg, " + originalColorTransparent + ", " + originalColorTransparent + " 69%, " + originalColor + " 70%, " + originalColor + ")"
      });
      return colorPreview;
    };
    makeKnob = function(size) {
      var el;
      el = document.createElement("div");
      el.className = "knob";
      style(el, {
        position: "absolute",
        width: size + "px",
        height: size + "px",
        backgroundColor: "red",
        borderRadius: Math.floor(size / 2) + "px",
        cursor: "pointer",
        backgroundImage: "-webkit-gradient(radial, 50% 0%, 0, 50% 0%, 15, color-stop(0%, rgba(255, 255, 255, 0.8)), color-stop(100%, rgba(255, 255, 255, 0.2)))",
        boxShadow: "white 0px 1px 1px inset, rgba(0, 0, 0, 0.4) 0px -1px 1px inset, rgba(0, 0, 0, 0.4) 0px 1px 4px 0px, rgba(0, 0, 0, 0.6) 0 0 2px"
      });
      style(el, {
        backgroundImage: "radial-gradient(circle at center top, rgba(255,255,255,0.8), rgba(255, 255, 255, 0.2) 15px"
      });
      return el;
    };
    Picker.prototype.presentModal = function(x, y) {
      var modalFrame, _this = this;
      style(this.el, {
        left: x + "px",
        top: y - 10 + "px",
        opacity: "0",
        webkitTransition: "0.15s",
        MozTransition: "0.15s"
      });
      modalFrame = document.createElement("div");
      modalFrame.style.position = "fixed";
      modalFrame.style.top = modalFrame.style.left = modalFrame.style.bottom = modalFrame.style.right = "0";
      modalFrame.style.zIndex = "999";
      modalFrame.onclick = function() {
        var end;
        document.body.removeChild(modalFrame);
        _this.el.style.top = y + 10 + "px";
        _this.el.style.opacity = 0;
        end = function() {
          document.body.removeChild(_this.el);
          _this.el.removeEventListener("webkitTransitionEnd", end);
          return _this.el.removeEventListener("transitionend", end);
        };
        _this.el.addEventListener("webkitTransitionEnd", end);
        _this.el.addEventListener("transitionend", end);
        return _this.emit("closed");
      };
      document.body.appendChild(modalFrame);
      document.body.appendChild(this.el);
      this.el.offsetHeight;
      this.el.style.opacity = "1";
      this.el.style.top = y + "px";
      return this;
    };
    Picker.prototype.presentModalBeneath = function(el) {
      var elPos, x, y;
      elPos = el.getBoundingClientRect();
      x = elPos.left + window.scrollX;
      y = elPos.bottom + window.scrollY + 4;
      return this.presentModal(x, y);
    };
    return Picker;
  }();
  window.thistle = {
    Picker: Picker,
    isValidCSSColor: isValidCSSColor
  };
})).call(this);

if (typeof Color === "undefined") var Color = {};

(function() {
  Color.Picker = function(props) {
    var that = this;
    if (typeof props === "undefined") props = {};
    this.callback = props.callback;
    if (props.color[0] === "#") {
      this.color = Color.Space(props.color.substr(1), "STRING>HEX>RGB>HSV");
      this.color.A = 255;
    } else if (props.color.substr(0, 4) === "rgba") {
      this.color = Color.Space(props.color, "W3>RGBA>HSVA");
    }
    this.eyedropLayer = props.eyedropLayer;
    this.eyedropMouseLayer = props.eyedropMouseLayer || props.eyedropLayer;
    this.container = props.container || document.body;
    this.size = props.size || 200;
    this.margin = props.margin || 10;
    this.offset = this.margin / 2;
    this.hueWidth = props.hueWidth || 38;
    this.doAlpha = false;
    var plugin = document.createElement("div");
    plugin.className = "ColorPicker";
    var pickerWidth = this.size + this.hueWidth * (this.doAlpha ? 2 : 1) + this.margin - 6;
    var pickerHeight = this.size + this.margin * 2;
    plugin.style.height = pickerHeight + "px";
    plugin.style.width = pickerWidth + "px";
    plugin.style.display = props.display ? "block" : "none";
    this.container.appendChild(plugin);
    this.element = plugin;
    var hexBoxContainer = document.createElement("div");
    hexBoxContainer.style.backgroundImage = "url(" + interlace.data + ")";
    hexBoxContainer.className = "hexBox";
    hexBoxContainer.title = "Eyedropper";
    if (that.eyedropMouseLayer) {
      Event.add(hexBoxContainer, "mousedown", Event.cancel);
      Event.add(hexBoxContainer, "click", function() {
        document.body.style.cursor = "crosshair";
        var close = function(event) {
          document.body.style.cursor = "pointer";
          var coord = Event.coords(event);
          var ctx = that.eyedropLayer.getContext("2d");
          var data = ctx.getImageData(coord.x, coord.y, 1, 1);
          var color = Color.Space(data.data, "RGBA>HSVA");
          that.update(color, "HSVA");
          Event.remove(that.eyedropMouseLayer, "mousedown", close);
        };
        Event.add(that.eyedropMouseLayer, "mousedown", close);
      });
    }
    var hexBox = document.createElement("div");
    hexBoxContainer.appendChild(hexBox);
    plugin.appendChild(hexBoxContainer);
    var isHex = /[^a-f0-9]/gi;
    var hexInput = document.createElement("input");
    hexInput.title = "HEX Code";
    hexInput.className = "hexInput";
    hexInput.size = 6;
    hexInput.type = "text";
    Event.add(hexInput, "mousedown", Event.stopPropagation);
    Event.add(hexInput, "keydown change", function(event) {
      var code = event.keyCode;
      var value = hexInput.value.replace(isHex, "").substr(0, 6);
      var hex = parseInt("0x" + value);
      if (event.type == "keydown") {
        if (code == 40) {
          hex = Math.max(0, hex - (event.shiftKey ? 10 : 1));
          hexInput.value = Color.Space(hex, "HEX>STRING");
        } else if (code == 38) {
          hex = Math.min(16777215, hex + (event.shiftKey ? 10 : 1));
          hexInput.value = Color.Space(hex, "HEX>STRING");
        } else {
          return;
        }
      }
      if (String(hex) === "NaN") return;
      if (hex > 16777215) hex = 16777215;
      if (hex < 0) hex = 0;
      var update = event.type == "change" ? "" : "hex";
      that.update(Color.Space(hex, "HEX>RGB"), "RGB");
      if (event.keyCode == 27) this.blur();
    });
    plugin.appendChild(hexInput);
    var hexClose = document.createElement("div");
    hexClose.title = "Close";
    hexClose.className = "hexClose";
    hexClose.innerHTML = "x";
    Event.add(hexClose, "mousedown", Event.cancel);
    Event.add(hexClose, "click", function(event) {
      that.toggle(false);
    });
    plugin.appendChild(hexClose);
    plugin.appendChild(document.createElement("br"));
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    canvas.style.cssText = "position: absolute; top: 32px; left: " + this.offset + "px;";
    canvas.width = this.size + this.hueWidth * 2 + this.margin + 2;
    canvas.height = this.size + this.margin;
    plugin.appendChild(canvas);
    var mouse = function(event) {
      var down = event.type === "mousedown" || event.type === "touchstart";
      if (down) {
        Event.stop(event);
        hexInput.blur();
      }
      var offset = that.margin / 2;
      var abs = {
        x: 0,
        y: 0
      };
      if (window !== canvas) {
        var tmp = canvas;
        while (tmp !== null) {
          abs.x += tmp.offsetLeft;
          abs.y += tmp.offsetTop;
          tmp = tmp.offsetParent;
        }
      }
      var x0 = event.pageX - abs.x - offset;
      var y0 = event.pageY - abs.y - offset;
      var x = clamp(x0, 0, canvas.width);
      var y = clamp(y0, 0, that.size);
      if (event.target.className === "hexInput") {
        plugin.style.cursor = "text";
        return;
      } else if (x !== x0 || y !== y0) {
        plugin.style.cursor = "move";
        plugin.title = "Move";
        if (down) dragElement({
          type: "move",
          event: event,
          element: plugin,
          callback: function(event, self) {
            plugin.style.left = self.x + "px";
            plugin.style.top = self.y + "px";
            Event.prevent(event);
          }
        });
      } else if (x <= that.size) {
        plugin.style.cursor = "crosshair";
        plugin.title = "Saturation + Value";
        if (down) dragElement({
          type: "difference",
          event: event,
          element: canvas,
          callback: function(event, self) {
            var x = clamp(self.x - that.offset, 0, that.size);
            var y = clamp(self.y - that.offset, 0, that.size);
            that.color.S = x / that.size * 100;
            that.color.V = 100 - y / that.size * 100;
            that.drawSample(self.state, true);
            Event.prevent(event);
          }
        });
      } else if (x > that.size + that.margin && x <= that.size + that.hueWidth) {
        plugin.style.cursor = "crosshair";
        plugin.title = "Hue";
        if (down) dragElement({
          type: "difference",
          event: event,
          element: canvas,
          callback: function(event, self) {
            var y = clamp(self.y - that.offset, 0, that.size);
            that.color.H = 360 - Math.min(1, y / that.size) * 360;
            that.drawSample(self.state, true);
            Event.prevent(event);
          }
        });
      } else if (x > that.size + that.hueWidth + that.margin && x <= that.size + that.hueWidth * 2) {
        plugin.style.cursor = "crosshair";
        plugin.title = "Alpha";
        if (down) dragElement({
          type: "difference",
          event: event,
          element: canvas,
          callback: function(event, self) {
            var y = clamp(self.y - that.offset, 0, that.size);
            that.color.A = (1 - Math.min(1, y / that.size)) * 255;
            that.drawSample(self.state, true);
            Event.prevent(event);
          }
        });
      } else {
        plugin.style.cursor = "default";
      }
      return false;
    };
    Event.add(plugin, "mousemove", mouse);
    Event.add(plugin, "mousedown", mouse);
    this.update = function(color) {
      if (typeof color === "string") {
        that.color = Color.Space(color, "STRING>HEX>RGB>HSV");
      } else if (typeof color.R !== "undefined") {
        that.color = Color.Space(color, "RGB>HSV");
      } else if (typeof color.H !== "undefined") {
        that.color = color;
      }
      if (typeof color.A === "undefined") {
        that.color.A = 255;
      }
      that.drawSample("update", true);
    };
    this.drawSample = function(state, update) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      that.drawSquare();
      that.drawHue();
      if (this.doAlpha) that.drawAlpha();
      var rgba = Color.Space(that.color, "HSVA>RGBA");
      var hex = Color.Space(rgba, "RGB>HEX>STRING");
      hexInput.value = hex.toUpperCase();
      hexBox.style.backgroundColor = Color.Space(rgba, "RGBA>W3");
      var y = (360 - that.color.H) / 362 * that.size - 2;
      ctx.drawImage(arrow, that.size + that.hueWidth + that.offset + 2, Math.round(y) + that.offset - 1);
      if (this.doAlpha) {
        var y = (255 - that.color.A) / 255 * that.size - 2;
        ctx.drawImage(arrow, that.size + that.hueWidth * 2 + that.offset + 2, Math.round(y) + that.offset - 1);
      }
      var x = that.color.S / 100 * that.size;
      var y = (1 - that.color.V / 100) * that.size;
      x = x - circle.width / 2;
      y = y - circle.height / 2;
      ctx.drawImage(circle, Math.round(x) + that.offset, Math.round(y) + that.offset);
      if (that.callback && state && update) {
        that.callback(rgba, state);
      }
    };
    this.drawSquare = function() {
      var hex = Color.Space({
        H: that.color.H,
        S: 100,
        V: 100
      }, "HSV>RGB>HEX>STRING");
      var rgb = Color.Space.HEX_RGB("0x" + hex);
      var offset = that.offset;
      var size = that.size;
      ctx.fillStyle = "#" + hex;
      ctx.fillRect(offset, offset, size, size);
      var gradient = ctx.createLinearGradient(offset, offset, size + offset, 0);
      gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
      gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
      ctx.fillStyle = gradient;
      ctx.fillRect(offset, offset, size, size);
      var gradient = ctx.createLinearGradient(0, offset, 0, size + offset);
      gradient.addColorStop(0, "rgba(0, 0, 0, 0)");
      gradient.addColorStop(1, "rgba(0, 0, 0, 1)");
      ctx.fillStyle = gradient;
      ctx.fillRect(offset, offset, size, size);
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.strokeRect(offset + .5, offset + .5, size - 1, size - 1);
    };
    this.drawHue = function() {
      var left = that.size + that.margin + that.offset;
      var gradient = ctx.createLinearGradient(0, 0, 0, that.size + that.offset);
      gradient.addColorStop(0, "rgba(255, 0, 0, 1)");
      gradient.addColorStop(5 / 6, "rgba(255, 255, 0, 1)");
      gradient.addColorStop(4 / 6, "rgba(0, 255, 0, 1)");
      gradient.addColorStop(3 / 6, "rgba(0, 255, 255, 1)");
      gradient.addColorStop(2 / 6, "rgba(0, 0, 255, 1)");
      gradient.addColorStop(1 / 6, "rgba(255, 0, 255, 1)");
      gradient.addColorStop(1, "rgba(255, 0, 0, 1)");
      ctx.fillStyle = gradient;
      ctx.fillRect(left, that.offset, that.hueWidth - 10, that.size);
      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.strokeRect(left + .5, that.offset + .5, that.hueWidth - 11, that.size - 1);
    };
    this.drawAlpha = function() {
      var left = that.size + that.margin + that.offset + that.hueWidth;
      ctx.fillStyle = interlace;
      ctx.fillRect(left, that.offset, that.hueWidth - 10, that.size);
      var rgb = Color.Space.HSV_RGB({
        H: that.color.H,
        S: that.color.S,
        V: that.color.V
      });
      var gradient = ctx.createLinearGradient(0, 0, 0, that.size);
      rgb.A = 255;
      gradient.addColorStop(0, Color.Space.RGBA_W3(rgb));
      rgb.A = 0;
      gradient.addColorStop(1, Color.Space.RGBA_W3(rgb));
      ctx.fillStyle = gradient;
      ctx.fillRect(left, that.offset, that.hueWidth - 10, that.size);
      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.strokeRect(left + .5, that.offset + .5, that.hueWidth - 11, that.size - 1);
    };
    this.toggle = function(display) {
      if (typeof display !== "boolean") {
        if (plugin.style.display === "block") {
          display = false;
        } else {
          display = true;
        }
      }
      if (display) {
        plugin.style.opacity = 1;
        plugin.style.display = "block";
      } else {
        plugin.style.opacity = 0;
        plugin.style.display = "none";
      }
      if (display && props.autoclose) {
        var mousedown = function() {
          Event.remove(window, "mousedown", mousedown);
          that.toggle(false);
        };
        Event.add(window, "mousedown", mousedown);
      }
    };
    this.destory = function() {
      document.body.removeChild(plugin);
      for (var key in that) delete that[key];
    };
    this.drawSample("create");
    return this;
  };
  var arrow = function() {
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    var size = 16;
    var width = size / 3;
    canvas.width = size;
    canvas.height = size;
    var top = -size / 4;
    var left = 0;
    for (var n = 0; n < 20; n++) {
      ctx.beginPath();
      ctx.fillStyle = "#fff";
      ctx.moveTo(left, size / 2 + top);
      ctx.lineTo(left + size / 4, size / 4 + top);
      ctx.lineTo(left + size / 4, size / 4 * 3 + top);
      ctx.fill();
    }
    ctx.translate(-width, -size);
    return canvas;
  }();
  var circle = function() {
    var canvas = document.createElement("canvas");
    canvas.width = 10;
    canvas.height = 10;
    var ctx = canvas.getContext("2d");
    ctx.lineWidth = 1;
    ctx.beginPath();
    var x = canvas.width / 2;
    var y = canvas.width / 2;
    ctx.arc(x, y, 4.5, 0, Math.PI * 2, true);
    ctx.strokeStyle = "#000";
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x, y, 3.5, 0, Math.PI * 2, true);
    ctx.strokeStyle = "#FFF";
    ctx.stroke();
    return canvas;
  }();
  var interlace = function(size, color1, color2) {
    var proto = document.createElement("canvas").getContext("2d");
    proto.canvas.width = size * 2;
    proto.canvas.height = size * 2;
    proto.fillStyle = color1;
    proto.fillRect(0, 0, size, size);
    proto.fillStyle = color2;
    proto.fillRect(size, 0, size, size);
    proto.fillStyle = color2;
    proto.fillRect(0, size, size, size);
    proto.fillStyle = color1;
    proto.fillRect(size, size, size, size);
    var pattern = proto.createPattern(proto.canvas, "repeat");
    pattern.data = proto.canvas.toDataURL();
    return pattern;
  }(8, "#FFF", "#eee");
  var clamp = function(n, min, max) {
    return n < min ? min : n > max ? max : n;
  };
  var dragElement = function(props) {
    function mouseMove(e, state) {
      if (typeof state == "undefined") state = "move";
      var coord = XY(e);
      switch (props.type) {
       case "move":
        props.callback(event, {
          x: coord.x + oX - eX,
          y: coord.y + oY - eY,
          state: state
        });
        break;
       case "difference":
        props.callback(event, {
          x: coord.x - oX,
          y: coord.y - oY,
          state: state
        });
        break;
       default:
        props.callback(event, {
          x: coord.x,
          y: coord.y,
          state: state
        });
        break;
      }
    }
    function mouseUp(e) {
      window.removeEventListener("mousemove", mouseMove, false);
      window.removeEventListener("mouseup", mouseUp, false);
      mouseMove(e, "up");
    }
    var el = props.element;
    var origin = {
      x: 0,
      y: 0
    };
    if (window !== el) {
      var tmp = el;
      while (tmp !== null) {
        origin.x += tmp.offsetLeft;
        origin.y += tmp.offsetTop;
        tmp = tmp.offsetParent;
      }
    }
    var oX = origin.x;
    var oY = origin.y;
    var e = props.event;
    var coord = XY(e);
    var eX = coord.x;
    var eY = coord.y;
    window.addEventListener("mousemove", mouseMove, false);
    window.addEventListener("mouseup", mouseUp, false);
    mouseMove(e, "down");
  };
  var Event = {
    add: function(target, type, listener) {
      if (type.indexOf(" ") !== -1) {
        type = type.split(" ");
        for (var n = 0; n < type.length; n++) {
          Event.add(target, type[n], listener);
        }
      } else {
        if (target.addEventListener) {
          target.addEventListener(type, listener, false);
        } else if (target.attachEvent) {
          target.attachEvent(type, listener);
        }
      }
    },
    remove: function(target, type, listener) {
      if (target.removeEventListener) {
        target.removeEventListener(type, listener, false);
      } else if (target.detachEvent) {
        target.detachEvent(type, listener);
      }
    },
    stop: function(event) {
      if (event.stopPropagation) {
        event.stopPropagation();
      } else {
        event.cancelBubble = true;
      }
    },
    prevent: function(event) {
      if (event.preventDefault) {
        event.preventDefault();
      } else {
        event.returnValue = false;
      }
    }
  };
  var XY = window.ActiveXObject ? function(event) {
    return {
      x: event.clientX + document.documentElement.scrollLeft,
      y: event.clientY + document.documentElement.scrollTop
    };
  } : function(event) {
    return {
      x: event.pageX,
      y: event.pageY
    };
  };
})();

if (typeof Color === "undefined") Color = {};

if (typeof Color.Space === "undefined") Color.Space = {};

(function() {
  var DEG_RAD = Math.PI / 180;
  var RAD_DEG = 1 / DEG_RAD;
  var functions = {};
  var shortcuts = {
    "RGB>STRING": "RGB>HEX>STRING",
    "STRING>RGB": "STRING>HEX>RGB"
  };
  var root = Color.Space = function(color, route) {
    if (shortcuts[route]) {
      route = shortcuts[route];
    }
    var r = route.split(">");
    if (typeof color === "object" && color[0] >= 0) {
      var type = route.split(">")[0];
      var tmp = {};
      for (var i = 0; i < type.length; i++) {
        var str = type.substr(i, 1);
        tmp[str] = color[i];
      }
      color = tmp;
    }
    if (functions[route]) {
      return functions[route](color);
    }
    var f = "color";
    for (var pos = 1, key = r[0]; pos < r.length; pos++) {
      if (pos > 1) {
        key = key.substr(key.indexOf("_") + 1);
      }
      key += (pos === 0 ? "" : "_") + r[pos];
      color = root[key](color);
      f = "Color.Space." + key + "(" + f + ")";
    }
    functions[route] = eval("(function(color) { return " + f + " })");
    return color;
  };
  root.RGB_W3 = function(o) {
    return "rgb(" + (o.R >> 0) + "," + (o.G >> 0) + "," + (o.B >> 0) + ")";
  };
  root.RGBA_W3 = function(o) {
    var alpha = typeof o.A === "number" ? o.A / 255 : 1;
    return "rgba(" + (o.R >> 0) + "," + (o.G >> 0) + "," + (o.B >> 0) + "," + alpha + ")";
  };
  root.W3_RGB = function(o) {
    var o = o.substr(4, o.length - 5).split(",");
    return {
      R: parseInt(o[0]),
      G: parseInt(o[1]),
      B: parseInt(o[2])
    };
  };
  root.W3_RGBA = function(o) {
    var o = o.substr(5, o.length - 6).split(",");
    return {
      R: parseInt(o[0]),
      G: parseInt(o[1]),
      B: parseInt(o[2]),
      A: parseFloat(o[3]) * 255
    };
  };
  root.STRING_HEX = function(o) {
    return parseInt("0x" + o);
  };
  root.STRING_HEX32 = function(o) {
    if (o.length === 6) {
      return parseInt("0xFF" + o);
    } else {
      return parseInt("0x" + o);
    }
  };
  root.HEX_STRING = function(o, maxLength) {
    if (!maxLength) maxLength = 6;
    if (!o) o = 0;
    var z = o.toString(16);
    var n = z.length;
    while (n < maxLength) {
      z = "0" + z;
      n++;
    }
    var n = z.length;
    while (n > maxLength) {
      z = z.substr(1);
      n--;
    }
    return z;
  };
  root.HEX32_STRING = function(o) {
    return root.HEX_STRING(o, 8);
  };
  root.HEX_RGB = function(o) {
    return {
      R: o >> 16,
      G: o >> 8 & 255,
      B: o & 255
    };
  };
  root.HEX32_RGBA = function(o) {
    return {
      R: o >>> 16 & 255,
      G: o >>> 8 & 255,
      B: o & 255,
      A: o >>> 24
    };
  };
  root.RGBA_HEX32 = function(o) {
    return (o.A << 24 | o.R << 16 | o.G << 8 | o.B) >>> 0;
  };
  root.RGB_HEX = function(o) {
    if (o.R < 0) o.R = 0;
    if (o.G < 0) o.G = 0;
    if (o.B < 0) o.B = 0;
    if (o.R > 255) o.R = 255;
    if (o.G > 255) o.G = 255;
    if (o.B > 255) o.B = 255;
    return o.R << 16 | o.G << 8 | o.B;
  };
  root.RGBA_HSVA = root.RGB_HSV = function(o) {
    var _R = o.R / 255, _G = o.G / 255, _B = o.B / 255, min = Math.min(_R, _G, _B), max = Math.max(_R, _G, _B), D = max - min, H, S, V = max;
    if (D === 0) {
      H = 0;
      S = 0;
    } else {
      S = D / max;
      var DR = ((max - _R) / 6 + D / 2) / D;
      var DG = ((max - _G) / 6 + D / 2) / D;
      var DB = ((max - _B) / 6 + D / 2) / D;
      if (_R === max) H = DB - DG; else if (_G === max) H = 1 / 3 + DR - DB; else if (_B === max) H = 2 / 3 + DG - DR;
      if (H < 0) H += 1;
      if (H > 1) H -= 1;
    }
    return {
      H: H * 360,
      S: S * 100,
      V: V * 100,
      A: o.A
    };
  };
  root.HSVA_RGBA = root.HSV_RGB = function(o) {
    var H = o.H / 360;
    var S = o.S / 100;
    var V = o.V / 100;
    var R, G, B;
    if (S === 0) {
      R = G = B = Math.round(V * 255);
    } else {
      if (H >= 1) H = 0;
      H = 6 * H;
      D = H - Math.floor(H);
      A = Math.round(255 * V * (1 - S));
      B = Math.round(255 * V * (1 - S * D));
      C = Math.round(255 * V * (1 - S * (1 - D)));
      V = Math.round(255 * V);
      switch (Math.floor(H)) {
       case 0:
        R = V;
        G = C;
        B = A;
        break;
       case 1:
        R = B;
        G = V;
        B = A;
        break;
       case 2:
        R = A;
        G = V;
        B = C;
        break;
       case 3:
        R = A;
        G = B;
        B = V;
        break;
       case 4:
        R = C;
        G = A;
        B = V;
        break;
       case 5:
        R = V;
        G = A;
        B = B;
        break;
      }
    }
    return {
      R: R,
      G: G,
      B: B,
      A: o.A
    };
  };
})();

Inlet = function() {
  function inlet(ed, options) {
    var editor = ed;
    var slider;
    var picker;
    if (!options) options = {};
    if (!options.picker) options.picker = {};
    if (!options.slider) options.slider = {};
    var container = options.container || document.body;
    var topOffset = options.picker.topOffset || 220;
    var bottomOffset = options.picker.bottomOffset || 16;
    var topBoundary = options.picker.topBoundary || 250;
    var leftOffset = options.picker.leftOffset || 75;
    var y_offset = options.slider.yOffset || 15;
    var wrapper = editor.getWrapperElement();
    wrapper.addEventListener("mousedown", onClick);
    editor.setOption("onKeyEvent", onKeyDown);
    var sliderDiv = document.createElement("div");
    sliderDiv.className = "inlet_slider";
    sliderDiv.style.visibility = "hidden";
    sliderDiv.style.position = "absolute";
    sliderDiv.style.top = 0;
    container.appendChild(sliderDiv);
    var slider = document.createElement("input");
    slider.className = "range";
    slider.setAttribute("type", "range");
    slider.addEventListener("change", onSlide);
    slider.addEventListener("mouseup", onSlideMouseUp);
    sliderDiv.appendChild(slider);
    function onSlide(event) {
      var value = String(slider.value);
      var cursor = editor.getCursor(true);
      var number = getNumber(cursor);
      if (!number) return;
      var start = {
        line: cursor.line,
        ch: number.start
      };
      var end = {
        line: cursor.line,
        ch: number.end
      };
      editor.replaceRange(value, start, end);
    }
    function onSlideMouseUp(event) {
      slider.value = 0;
      var cursor = editor.getCursor(true);
      var number = getNumber(cursor);
      if (!number) return;
      var value = parseFloat(number.string);
      var sliderRange = getSliderRange(value);
      slider.setAttribute("value", value);
      slider.setAttribute("step", sliderRange.step);
      slider.setAttribute("min", sliderRange.min);
      slider.setAttribute("max", sliderRange.max);
      slider.value = value;
    }
    var LEFT = 37;
    var UP = 38;
    var RIGHT = 39;
    var DOWN = 40;
    function onKeyDown() {
      if (arguments.length == 1) {
        event = arguments[0];
      } else {
        event = arguments[1];
      }
      if (event.keyCode == LEFT || event.keyCode == DOWN) {
        if (sliderDiv.style.visibility === "visible") {
          slider.stepDown(1);
          onSlide();
          return true;
        } else if (event.altKey) {
          onClick();
        } else {}
      } else if (event.keyCode == RIGHT || event.keyCode == UP) {
        if (sliderDiv.style.visibility === "visible") {
          slider.stepUp(1);
          onSlide();
          return true;
        } else if (event.altKey) {
          onClick();
        } else {}
      } else {
        sliderDiv.style.visibility = "hidden";
      }
    }
    var pickerCallback = function(color, state, type) {
      var cursor = editor.getCursor();
      var hex = getHsl(cursor);
      if (!hex) return;
      var start = {
        line: cursor.line,
        ch: hex.start
      };
      var end = {
        line: cursor.line,
        ch: hex.end
      };
      editor.replaceRange(color, start, end);
    };
    function onClick(ev) {
      var cursor = editor.getCursor(true);
      var token = editor.getTokenAt(cursor);
      cursorOffset = editor.cursorCoords(true, "page");
      var number = getNumber(cursor);
      var hexMatch = getHsl(cursor);
      if (hexMatch) {
        var color = hexMatch.string;
        var top = cursorOffset.top - topOffset;
        if (cursorOffset.top < topBoundary) {
          top = cursorOffset.top + bottomOffset;
        }
        var left = cursorOffset.left - leftOffset;
        picker = new thistle.Picker(color);
        picker.setCSS(color);
        picker.presentModal(left, top);
        picker.on("changed", function() {
          picked = picker.getCSS();
          pickerCallback(picked);
        });
        sliderDiv.style.visibility = "hidden";
      } else if (number) {
        slider.value = 0;
        var value = parseFloat(number.string);
        var sliderRange = getSliderRange(value);
        slider.setAttribute("value", value);
        slider.setAttribute("step", sliderRange.step);
        slider.setAttribute("min", sliderRange.min);
        slider.setAttribute("max", sliderRange.max);
        slider.value = value;
        var sliderTop = cursorOffset.top - y_offset;
        var sliderStyle = window.getComputedStyle(sliderDiv);
        var sliderWidth = getPixels(sliderStyle.width);
        var sliderLeft = cursorOffset.left - sliderWidth / 2;
        sliderDiv.style.top = sliderTop - 10 + "px";
        sliderDiv.style.left = sliderLeft + "px";
        sliderDiv.style.visibility = "visible";
      } else {
        sliderDiv.style.visibility = "hidden";
      }
    }
    function getSliderRange(value) {
      var range, step, sliderMin, sliderMax;
      if (value === 0) {
        range = [ -100, 100 ];
      } else {
        range = [ -value * 3, value * 5 ];
      }
      if (range[0] < range[1]) {
        min = range[0];
        max = range[1];
      } else {
        min = range[1];
        max = range[0];
      }
      if (max - min > 20) {
        step = 1;
      } else {
        step = (max - min) / 200;
      }
      return {
        min: min,
        max: max,
        step: step
      };
    }
    function getHsl(cursor) {
      var line = editor.getLine(cursor.line);
      var re = /hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)/g;
      var match = re.exec(line);
      while (match) {
        var val = match[0];
        var len = val.length;
        var start = match.index;
        var end = match.index + len;
        if (cursor.ch >= start && cursor.ch <= end) {
          match = null;
          return {
            start: start,
            end: end,
            string: val
          };
        }
        match = re.exec(line);
      }
      return;
    }
    function getHex(cursor) {
      var line = editor.getLine(cursor.line);
      var re = /#[a-fA-F0-9]{3,6}/g;
      var match = re.exec(line);
      while (match) {
        var val = match[0];
        var len = val.length;
        var start = match.index;
        var end = match.index + len;
        if (cursor.ch >= start && cursor.ch <= end) {
          match = null;
          return {
            start: start,
            end: end,
            string: val
          };
        }
        match = re.exec(line);
      }
      return;
    }
    function getNumber(cursor) {
      var line = editor.getLine(cursor.line);
      var re = /[-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g;
      var match = re.exec(line);
      while (match) {
        var val = match[0];
        var len = val.length;
        var start = match.index;
        var end = match.index + len;
        if (cursor.ch >= start && cursor.ch <= end) {
          match = null;
          return {
            start: start,
            end: end,
            string: val
          };
        }
        match = re.exec(line);
      }
      return;
    }
  }
  function getPixels(style) {
    var pix = 0;
    if (style.length > 2) {
      pix = parseFloat(style.slice(0, style.length - 2));
    }
    if (!pix) pix = 0;
    return pix;
  }
  function getOffset(el) {
    var _x = 0;
    var _y = 0;
    while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
      _x += el.offsetLeft - el.scrollLeft;
      _y += el.offsetTop - el.scrollTop;
      el = el.offsetParent;
    }
    return {
      top: _y,
      left: _x
    };
  }
  return inlet;
}();